# =============================================================================
# ğŸ¦ OPSERA DevOps Copilot - CI/CD Workflow
# Skill Version: 4.0.0
# App: play1 | Cloud: AWS | Tenant: opsera
# =============================================================================
name: "ğŸ”„ CI/CD - play1"

on:
  push:
    branches: [main]
    paths:
      - 'src/**'
      - 'public/**'
      - 'package.json'
      - 'package-lock.json'
      - 'vite.config.ts'
      - 'tsconfig.json'
      - 'index.html'
      - '.opsera-play1/Dockerfile'
      - '.opsera-play1/nginx.conf'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'dev'
        type: string

env:
  APP_NAME: play1
  TENANT: opsera
  AWS_REGION: us-west-2
  SPOKE_CLUSTER: opsera-usw2-np
  OPSERA_FOLDER: .opsera-play1
  ENVIRONMENT: ${{ inputs.environment || 'dev' }}

concurrency:
  group: ci-cd-play1-${{ github.ref }}
  cancel-in-progress: true

# Required for SARIF upload to GitHub Security tab
permissions:
  contents: write
  security-events: write
  actions: read

jobs:
  # =========================================================================
  # Job 1: Verify Bootstrap
  # =========================================================================
  verify-bootstrap:
    name: "âœ… Verify Bootstrap"
    runs-on: ubuntu-latest
    outputs:
      ecr_uri: ${{ steps.ecr.outputs.uri }}
      should_deploy: ${{ steps.check.outputs.should_deploy }}
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get AWS Account ID and ECR URI
        id: ecr
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_REPO="${{ env.TENANT }}/${{ env.APP_NAME }}"
          ECR_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${ECR_REPO}"
          
          echo "uri=${ECR_URI}" >> $GITHUB_OUTPUT
          echo "âœ… ECR URI: ${ECR_URI}"

      - name: Verify ECR Repository
        id: check
        run: |
          ECR_REPO="${{ env.TENANT }}/${{ env.APP_NAME }}"
          
          if aws ecr describe-repositories --repository-names "${ECR_REPO}" 2>/dev/null; then
            echo "âœ… ECR repository exists"
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          else
            echo "âŒ ECR repository not found. Run bootstrap workflow first."
            echo "should_deploy=false" >> $GITHUB_OUTPUT
            exit 1
          fi

  # =========================================================================
  # Job 2: SonarQube Scan (Optional - Warn Only)
  # =========================================================================
  sonarqube-scan:
    name: "ğŸ” SonarQube Scan"
    runs-on: ubuntu-latest
    needs: verify-bootstrap
    continue-on-error: true
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci --legacy-peer-deps

      - name: Run tests with coverage
        run: npm run test || true

      - name: SonarQube Scan
        uses: sonarsource/sonarqube-scan-action@master
        continue-on-error: true
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}

      - name: Check Quality Gate
        run: |
          echo "âš ï¸ SonarQube scan complete (warn-only mode)"
          echo "Check results at: ${{ secrets.SONAR_HOST_URL }}/dashboard?id=${{ github.event.repository.name }}"

  # =========================================================================
  # Job 3: Build Docker Image
  # =========================================================================
  build-image:
    name: "ğŸ”¨ Build Docker Image"
    runs-on: ubuntu-latest
    needs: [verify-bootstrap, sonarqube-scan]
    if: always() && needs.verify-bootstrap.result == 'success'
    outputs:
      image_tag: ${{ steps.build.outputs.image_tag }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Generate image tag
        id: tag
        run: |
          IMAGE_TAG="${GITHUB_SHA:0:7}-$(date +%Y%m%d%H%M%S)"
          echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "âœ… Image tag: ${IMAGE_TAG}"

      - name: Build Docker image
        id: build
        run: |
          IMAGE_TAG="${{ steps.tag.outputs.image_tag }}"
          
          docker build \
            --build-arg VITE_SUPABASE_URL="${{ secrets.VITE_SUPABASE_URL }}" \
            --build-arg VITE_SUPABASE_PUBLISHABLE_KEY="${{ secrets.VITE_SUPABASE_PUBLISHABLE_KEY }}" \
            -t "${{ env.APP_NAME }}:${IMAGE_TAG}" \
            -f ${{ env.OPSERA_FOLDER }}/Dockerfile .
          
          # Save image to tar for scanning
          docker save "${{ env.APP_NAME }}:${IMAGE_TAG}" > image.tar
          
          echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "âœ… Built image: ${{ env.APP_NAME }}:${IMAGE_TAG}"

      - name: Upload image artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: image.tar
          retention-days: 1

  # =========================================================================
  # Job 4: Grype Security Scan
  # =========================================================================
  grype-scan:
    name: "ğŸ”’ Grype Security Scan"
    runs-on: ubuntu-latest
    needs: build-image
    continue-on-error: true
    steps:
      - name: Download image artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image

      - name: Load Docker image
        run: docker load < image.tar

      - name: Run Grype scan
        uses: anchore/scan-action@v3
        id: scan
        with:
          image: "${{ env.APP_NAME }}:${{ needs.build-image.outputs.image_tag }}"
          fail-build: true
          severity-cutoff: critical
          output-format: sarif

      - name: Upload SARIF report
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: ${{ steps.scan.outputs.sarif }}

      - name: Display scan results
        if: always()
        run: |
          echo "ğŸ”’ Grype scan complete"
          echo "Check results in GitHub Security tab"

  # =========================================================================
  # Job 5: Push to ECR
  # =========================================================================
  push-image:
    name: "ğŸ“¤ Push to ECR"
    runs-on: ubuntu-latest
    needs: [verify-bootstrap, build-image, grype-scan]
    if: always() && needs.build-image.result == 'success'
    outputs:
      full_image_uri: ${{ steps.push.outputs.full_image_uri }}
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Download image artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image

      - name: Load Docker image
        run: docker load < image.tar

      - name: Login to ECR
        run: |
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | \
            docker login --username AWS --password-stdin ${{ needs.verify-bootstrap.outputs.ecr_uri }}

      - name: Tag and Push image
        id: push
        run: |
          ECR_URI="${{ needs.verify-bootstrap.outputs.ecr_uri }}"
          IMAGE_TAG="${{ needs.build-image.outputs.image_tag }}"
          FULL_IMAGE_URI="${ECR_URI}:${IMAGE_TAG}"
          
          docker tag "${{ env.APP_NAME }}:${IMAGE_TAG}" "${FULL_IMAGE_URI}"
          docker push "${FULL_IMAGE_URI}"
          
          echo "full_image_uri=${FULL_IMAGE_URI}" >> $GITHUB_OUTPUT
          echo "âœ… Pushed: ${FULL_IMAGE_URI}"

  # =========================================================================
  # Job 6: Update Kustomize and Deploy
  # =========================================================================
  deploy:
    name: "ğŸš€ Update Kustomize & Deploy"
    runs-on: ubuntu-latest
    needs: [verify-bootstrap, build-image, push-image]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}
          fetch-depth: 0

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Pull latest changes
        run: git pull --rebase origin main

      - name: Update Kustomization
        run: |
          ECR_URI="${{ needs.verify-bootstrap.outputs.ecr_uri }}"
          IMAGE_TAG="${{ needs.build-image.outputs.image_tag }}"
          KUSTOMIZE_FILE="${{ env.OPSERA_FOLDER }}/k8s/overlays/${{ env.ENVIRONMENT }}/kustomization.yaml"
          
          # Update image tag
          sed -i "s|newTag:.*|newTag: ${IMAGE_TAG}|" "$KUSTOMIZE_FILE"
          
          echo "âœ… Updated kustomization.yaml with tag: ${IMAGE_TAG}"
          cat "$KUSTOMIZE_FILE"

      - name: Commit and Push
        run: |
          git add .
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "chore: deploy play1 ${{ env.ENVIRONMENT }} - ${{ needs.build-image.outputs.image_tag }} [skip ci]"
            git push origin main
          fi

  # =========================================================================
  # Job 7: Wait for ArgoCD Sync
  # =========================================================================
  wait-argocd:
    name: "â³ Wait for ArgoCD Sync"
    runs-on: ubuntu-latest
    needs: deploy
    timeout-minutes: 10
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/v1.28.0/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

      - name: Connect to Hub Cluster
        run: |
          aws eks update-kubeconfig --name argocd-usw2 --region ${{ env.AWS_REGION }}

      - name: Wait for Sync
        run: |
          APP_NAME="${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}"
          
          echo "Waiting for ArgoCD to sync ${APP_NAME}..."
          
          for i in {1..60}; do
            SYNC=$(kubectl get application "${APP_NAME}" -n argocd \
              -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "Unknown")
            HEALTH=$(kubectl get application "${APP_NAME}" -n argocd \
              -o jsonpath='{.status.health.status}' 2>/dev/null || echo "Unknown")
            
            echo "[$i/60] Sync: ${SYNC} | Health: ${HEALTH}"
            
            if [ "$SYNC" = "Synced" ] && [ "$HEALTH" = "Healthy" ]; then
              echo "âœ… Application synced and healthy!"
              exit 0
            fi
            
            sleep 5
          done
          
          echo "âš ï¸ Timeout waiting for sync - check ArgoCD dashboard"

  # =========================================================================
  # Job 8: Deployment Summary
  # =========================================================================
  summary:
    name: "ğŸ“Š Deployment Summary"
    runs-on: ubuntu-latest
    needs: [verify-bootstrap, build-image, push-image, deploy, wait-argocd]
    if: always()
    steps:
      - name: Display Summary
        run: |
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘  ğŸ¦ OPSERA - Deployment Complete                                                 â•‘"
          echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
          echo "â•‘                                                                                  â•‘"
          echo "â•‘  App:         play1                                                              â•‘"
          echo "â•‘  Environment: ${{ env.ENVIRONMENT }}                                             â•‘"
          echo "â•‘  Image Tag:   ${{ needs.build-image.outputs.image_tag }}                         â•‘"
          echo "â•‘                                                                                  â•‘"
          echo "â•‘  Image URI:   ${{ needs.push-image.outputs.full_image_uri }}                     â•‘"
          echo "â•‘                                                                                  â•‘"
          echo "â•‘  Build:       ${{ needs.build-image.result }}                                    â•‘"
          echo "â•‘  Push:        ${{ needs.push-image.result }}                                     â•‘"
          echo "â•‘  Deploy:      ${{ needs.deploy.result }}                                         â•‘"
          echo "â•‘  Sync:        ${{ needs.wait-argocd.result }}                                    â•‘"
          echo "â•‘                                                                                  â•‘"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
